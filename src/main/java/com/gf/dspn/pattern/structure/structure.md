# 结构型模式

结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，
后者釆用组合或聚合来组合对象。

由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。

结构型模式分为以下 7 种：
    1.代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
    2.适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
    3.桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
    4.装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
    5.外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
    6.享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
    7.组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

    以上 7 种结构型模式，除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式



代理模式：
    在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，
可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。

    在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。
还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。

代理模式的定义与特点
    代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，
代理对象作为访问对象和目标对象之间的中介

    代理模式的主要优点有：
    .代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
    .代理对象可以扩展目标对象的功能；
    .代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性
    
    其主要缺点是：
    .代理模式会造成系统设计中类的数量增加
    .在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
    .增加了系统的复杂度；

    那么如何解决以上提到的缺点呢？答案是可以使用动态代理方式

代理模式的结构与实现
    代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问

    根据代理的创建时期，代理模式分为静态代理和动态代理。
    静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。
    动态：在程序运行时，运用反射机制动态创建而成

代理模式的应用场景
    当无法或不想直接引用某个对象或访问某个对象存在困难时，可以通过代理对象来间接访问。使用代理模式主要有两个目的：一是保护目标对象，二是增强目标对象。
    
    前面分析了代理模式的结构与特点，现在来分析以下的应用场景。
    .远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，
    会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。
    .虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，
    这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。
    .安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。
    .智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。
    .延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。

代理模式的扩展
    在前面介绍的代理模式中，代理类中包含了对真实主题的引用，这种方式存在两个缺点。
    1.真实主题与代理主题一一对应，增加真实主题也要增加代理。
    2.设计代理以前真实主题必须事先存在，不太灵活。采用动态代理模式可以解决以上问题，如 SpringAOP，其结构图如图 4 所示

适配器模式
    在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，
用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。

    在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，
这时用适配器模式能很好地解决这些问题。

模式的定义与特点
    适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

    该模式的主要优点如下。
    .客户端通过适配器可以透明地调用目标接口。
    .复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
    .将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。
    .在很多业务场景中符合开闭原则。
    
    其缺点是：
    .适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。
    .增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。

模式的应用场景
    适配器模式（Adapter）通常适用于以下场景。
    .以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。
    .使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。






